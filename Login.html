<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HenSpectral - Login</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet">

  <style>
    :root {
      --bg:#000000;
      --card:#1a1a1a;
      --muted:#888888;
      --text:#ffffff;
      --primary:#0088cc;
      --secondary:#3498db;
      --accent:#4da6d9;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body {
      font-family: Poppins, sans-serif;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 20% 20%, rgba(0,136,204,.1), transparent 30%),
                  radial-gradient(circle at 80% 10%, rgba(52,152,219,.08), transparent 25%),
                  radial-gradient(circle at 50% 90%, rgba(77,166,217,.05), transparent 30%),
                  var(--bg);
      padding: 20px;
      margin: 0;
    }
    .card {
      background:
        linear-gradient(135deg, rgba(255,255,255,.1), rgba(255,255,255,.05)),
        linear-gradient(45deg, rgba(0,136,204,.1), rgba(52,152,219,.05));
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 24px;
      padding: 35px 30px;
      width: 100%;
      max-width: 400px;
      text-align: center;
      box-shadow:
        0 8px 32px rgba(0,136,204,.3),
        0 0 60px rgba(52,152,219,.2),
        inset 0 1px 0 rgba(255,255,255,.2);
      animation: fadeIn 1s ease, floatCard 6s ease-in-out infinite;
      position: relative;
      min-height: auto;
      transform-style: preserve-3d;
      perspective: 1000px;
      display: flex;
      flex-direction: column;
    }

    /* Removed expensive shimmer animation for better performance */

    @keyframes floatCard {
      0%, 100% { transform: translateY(0) rotateX(0deg) rotateY(0deg); }
      50% { transform: translateY(-10px) rotateX(2deg) rotateY(1deg); }
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
      100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      border-radius: 20px 20px 0 0;
    }
    
    @keyframes fadeIn {
      from { opacity:0; transform:translateY(25px) scale(0.95); }
      to   { opacity:1; transform:translateY(0) scale(1); }
    }
    
    .logo-container {
      position: relative;
      width: 100px;
      height: 100px;
      margin: 0 auto 15px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logo-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: conic-gradient(
        #ffffff 0%,
        #0088cc 30%,
        #3498db 60%,
        #ffffff 100%
      );
      animation: rotate 3s linear infinite;
      padding: 4px;
    }

    .logo {
      width: 92px;
      height: 92px;
      border-radius: 50%;
      object-fit: cover;
      display: block;
      z-index: 1;
      position: relative;
      background: #1a1a1a;
      border: 2px solid rgba(255,255,255,0.1);
    }

    @keyframes rotate {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    /* Advanced Biometric Authentication */
    .biometric-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.8);
      border-radius: 50%;
      opacity: 0;
      visibility: hidden;
      transition: all 0.5s ease;
      cursor: pointer;
      z-index: 10;
      backdrop-filter: blur(10px);
    }

    .biometric-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .biometric-methods {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }

    .biometric-method {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 15px;
      border-radius: 12px;
      background: rgba(255,255,255,.1);
      border: 1px solid rgba(255,255,255,.2);
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .biometric-method:hover {
      background: rgba(0,136,204,.3);
      transform: translateY(-5px);
      box-shadow: 0 10px 20px rgba(0,136,204,.4);
    }

    .biometric-method.active {
      background: var(--primary);
      color: white;
    }

    .biometric-method span {
      font-size: 12px;
      font-weight: 500;
    }

    .biometric-icon {
      font-size: 24px;
      color: var(--primary);
      animation: biometricScan 2s ease-in-out infinite;
      z-index: 11;
    }

    .biometric-method:hover .biometric-icon {
      animation-duration: 0.5s;
    }

    .biometric-pulse {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 2px solid var(--primary);
      border-radius: 50%;
      animation: biometricPulse 3s ease-in-out infinite;
    }

    .gesture-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .gesture-hint.active {
      opacity: 1;
      visibility: visible;
    }

    .gesture-path {
      width: 100px;
      height: 100px;
      border: 2px dashed var(--primary);
      border-radius: 50%;
      position: relative;
      animation: gestureDraw 3s ease-in-out infinite;
    }

    .gesture-path::before {
      content: '';
      position: absolute;
      top: 10px;
      left: 10px;
      width: 80px;
      height: 80px;
      border: 1px solid var(--secondary);
      border-radius: 50%;
    }

    .gesture-hint span {
      color: var(--primary);
      font-size: 12px;
      font-weight: 500;
    }

    @keyframes biometricScan {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); opacity: 0.7; }
    }

    @keyframes biometricPulse {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(1.8); opacity: 0; }
    }

    @keyframes gestureDraw {
      0%, 100% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.1); }
    }


    /* Crisp Icon Rendering */
    .fas, .far, .fab {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      font-feature-settings: "liga" 1, "kern" 1;
      text-rendering: optimizeLegibility;
    }

    /* Advanced Loading States */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .loading-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .loading-content {
      text-align: center;
      color: white;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255,255,255,.2);
      border-top: 4px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 10px;
    }

    .loading-subtext {
      font-size: 14px;
      opacity: 0.8;
    }

    /* AI Processing Indicator */
    .ai-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0,136,204,.4);
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .ai-indicator:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(0,136,204,.6);
    }

    .ai-indicator i {
      color: white;
      font-size: 16px;
      animation: aiPulse 2s ease-in-out infinite;
    }

    @keyframes aiPulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }

    /* Gesture Drawing Canvas */
    .gesture-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
    }

    .gesture-path-drawn {
      stroke: var(--primary);
      stroke-width: 3;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    /* Cryptographic Animation */
    .crypto-animation {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      z-index: 100;
      opacity: 0.7;
    }

    .crypto-bits {
      position: absolute;
      width: 100%;
      height: 100%;
      animation: cryptoFlow 4s linear infinite;
    }

    .crypto-bits::before {
      content: '01010101';
      position: absolute;
      top: 0;
      left: 0;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: var(--primary);
      line-height: 1.2;
      animation: cryptoScroll 2s linear infinite;
    }

    @keyframes cryptoFlow {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes cryptoScroll {
      0% { transform: translateY(0); }
      100% { transform: translateY(-20px); }
    }
    
    .title {
      font-size:26px;
      font-family:Orbitron, sans-serif;
      font-weight:800;
      color: var(--text);
      margin-bottom:6px;
      text-shadow:0 0 15px rgba(255,255,255,.4);
      letter-spacing: 1px;
    }
    
    .subtitle {
      font-size:13px;
      color: var(--muted);
      margin-bottom:25px;
      font-weight:400;
      letter-spacing: 0.5px;
    }
    
    .form-group {
      position: relative;
      margin-bottom: 25px;
      animation: slideInUp 0.6s ease forwards;
      opacity: 0;
      transform: translateY(20px);
      display: flex;
      flex-direction: column;
    }

    .form-group:nth-child(1) { animation-delay: 0.2s; }
    .form-group:nth-child(2) { animation-delay: 0.4s; }

    @keyframes slideInUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .input-container {
      position: relative;
      width: 100%;
    }

    .form-group i {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--secondary);
      font-size: 18px;
      z-index: 2;
      transition: color 0.2s ease;
      pointer-events: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }


    input {
      width:100%;
      padding:16px 16px 16px 48px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.2);
      background: linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      color:var(--text);
      font-size:14px;
      outline:none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      font-weight:500;
      position: relative;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    input::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0,136,204,.1), transparent);
      transition: left 0.5s;
    }

    input:focus::before {
      left: 100%;
    }

    input:focus {
      border-color:var(--primary);
      box-shadow: 0 0 0 2px rgba(0,136,204,.3);
      background: linear-gradient(135deg, rgba(255,255,255,.12), rgba(255,255,255,.08));
      position: relative;
      z-index: 1;
    }

    input::placeholder {
      color: var(--muted);
      font-weight:400;
      transition: all 0.3s ease;
    }

    input:focus::placeholder {
      color: rgba(255,255,255,.6);
      transform: translateX(5px);
    }

    .input-error {
      border-color: #ff4757 !important;
      box-shadow: 0 0 0 3px rgba(255,71,87,.2) !important;
    }

    .input-success {
      border-color: #2ed573 !important;
      box-shadow: 0 0 0 3px rgba(46,213,115,.2) !important;
    }
    
    button {
      width: 100%;
      padding: 18px;
      font-size: 15px;
      font-weight: 600;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: white;
      transition: all .4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      box-shadow:
        0 4px 20px rgba(0,136,204,.4),
        0 0 30px rgba(52,152,219,.2);
      position: relative;
      overflow: hidden;
      margin-top: 20px;
      margin-bottom: 10px;
      letter-spacing: 0.5px;
      animation: slideInUp 0.6s ease forwards;
      opacity: 0;
      transform: translateY(20px);
      animation-delay: 0.6s;
      align-self: stretch;
    }

    .btn-text {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.3s ease;
    }

    .btn-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,.3);
      border-top: 2px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.3), transparent);
      transition: left 0.6s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      transform:translateY(-5px) scale(1.03);
      box-shadow:
        0 8px 30px rgba(0,136,204,.6),
        0 0 50px rgba(52,152,219,.4),
        inset 0 1px 0 rgba(255,255,255,.2);
    }

    button:active {
      transform:scale(0.97);
    }

    button.loading {
      pointer-events: none;
    }

    button.loading .btn-text {
      opacity: 0;
    }

    button.loading .btn-loader {
      display: flex !important;
    }

    /* Ripple effect */
    .ripple {
      position: absolute;
      border-radius: 50%;
      background: rgba(255,255,255,.6);
      transform: scale(0);
      animation: ripple 0.6s linear;
      pointer-events: none;
    }

    @keyframes ripple {
      to {
        transform: scale(4);
        opacity: 0;
      }
    }
    
    .buy-access {
      margin-top:20px;
      display:inline-block;
      font-size:13px;
      padding:12px 20px;
      border-radius:12px;
      font-weight:500;
      background:linear-gradient(135deg, var(--secondary), var(--accent));
      color:white;
      text-decoration:none;
      box-shadow:0 0 15px rgba(52,152,219,.4);
      font-family:Poppins, sans-serif;
      transition: all .3s ease;
      border: 1px solid rgba(255,255,255,.1);
      backdrop-filter: blur(10px);
    }
    
    .buy-access:hover {
      transform:translateY(-3px) scale(1.05);
      box-shadow:0 0 25px rgba(52,152,219,.6);
    }
    
    .buy-access i {
      margin-right: 6px;
    }
    
    .footer {
      margin-top:25px;
      font-size:11px;
      color:var(--muted);
      opacity: 0.8;
    }
    
    .toast {
      position:fixed;
      bottom:40px;
      left:50%;
      transform:translateX(-50%);
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color:white;
      padding:12px 20px;
      border-radius:10px;
      font-size:13px;
      font-weight:500;
      box-shadow:0 0 20px rgba(0,136,204,.4);
      opacity:0;
      animation: fadeInOut 4s ease forwards;
      z-index:100;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,.1);
    }
    
    @keyframes fadeInOut {
      0%{opacity:0; transform:translate(-50%,30px);}
      15%{opacity:1; transform:translate(-50%,0);}
      85%{opacity:1; transform:translate(-50%,0);}
      100%{opacity:0; transform:translate(-50%,30px);}
    }
    
    /* Advanced Particle background effect */
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }

    .particle {
      position: absolute;
      background: var(--primary);
      border-radius: 50%;
      opacity: 0.3;
      animation: float 6s infinite ease-in-out;
      transition: all 0.3s ease;
    }

    .particle.interactive {
      opacity: 0.6;
      transform: scale(1.5);
    }

    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(180deg); }
    }

    /* Neural Network Background */
    .neural-network {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -3;
      opacity: 0.3;
      pointer-events: none;
    }

    /* Quantum Field Effects */
    .quantum-field {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      pointer-events: none;
      overflow: hidden;
    }

    .wave-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: radial-gradient(circle, var(--primary), transparent);
      border-radius: 50%;
      animation: quantumWave 8s infinite ease-in-out;
    }

    .wave-particle:nth-child(1) {
      top: 20%;
      left: 10%;
      animation-delay: 0s;
      animation-duration: 6s;
    }

    .wave-particle:nth-child(2) {
      top: 60%;
      right: 15%;
      animation-delay: 2s;
      animation-duration: 8s;
    }

    .wave-particle:nth-child(3) {
      bottom: 30%;
      left: 70%;
      animation-delay: 4s;
      animation-duration: 7s;
    }

    .wave-particle:nth-child(4) {
      top: 40%;
      left: 50%;
      animation-delay: 1s;
      animation-duration: 9s;
    }

    .wave-particle:nth-child(5) {
      bottom: 20%;
      right: 30%;
      animation-delay: 3s;
      animation-duration: 5s;
    }

    @keyframes quantumWave {
      0%, 100% {
        transform: scale(1) rotate(0deg);
        opacity: 0.3;
      }
      25% {
        transform: scale(2) rotate(90deg);
        opacity: 0.8;
      }
      50% {
        transform: scale(1.5) rotate(180deg);
        opacity: 0.6;
      }
      75% {
        transform: scale(2.5) rotate(270deg);
        opacity: 0.4;
      }
    }

    /* Holographic Projection */
    .holographic-projection {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      height: 500px;
      z-index: -1;
      pointer-events: none;
      opacity: 0.1;
    }

    .holo-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 1px solid var(--primary);
      border-radius: 50%;
      animation: holoRotate 20s linear infinite;
    }

    .holo-layer-1 {
      animation-duration: 15s;
      animation-delay: 0s;
    }

    .holo-layer-2 {
      animation-duration: 20s;
      animation-delay: -5s;
      border-color: var(--secondary);
    }

    .holo-layer-3 {
      animation-duration: 25s;
      animation-delay: -10s;
      border-color: #4da6d9;
    }

    .holo-layer-4 {
      animation-duration: 30s;
      animation-delay: -15s;
      border-color: rgba(0,136,204,0.5);
      border-style: dashed;
    }

    @keyframes holoRotate {
      from { transform: rotate(0deg) scale(0.8); }
      to { transform: rotate(360deg) scale(1.2); }
    }

    /* Advanced Particle Canvas */
    .advanced-particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.4;
      pointer-events: none;
    }

    /* Animated background patterns */
    .bg-pattern {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      overflow: hidden;
    }

    .bg-shape {
      position: absolute;
      border-radius: 50%;
      background: linear-gradient(45deg, rgba(0,136,204,0.1), rgba(52,152,219,0.05));
      animation: morph 8s infinite ease-in-out;
    }

    .bg-shape:nth-child(1) {
      width: 300px;
      height: 300px;
      top: -150px;
      left: -150px;
      animation-delay: 0s;
    }

    .bg-shape:nth-child(2) {
      width: 200px;
      height: 200px;
      top: 60%;
      right: -100px;
      animation-delay: 2s;
    }

    .bg-shape:nth-child(3) {
      width: 150px;
      height: 150px;
      bottom: -75px;
      left: 50%;
      animation-delay: 4s;
    }

    @keyframes morph {
      0%, 100% {
        border-radius: 50%;
        transform: scale(1) rotate(0deg);
      }
      25% {
        border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
        transform: scale(1.1) rotate(90deg);
      }
      50% {
        border-radius: 70% 30% 30% 70% / 70% 70% 30% 30%;
        transform: scale(0.9) rotate(180deg);
      }
      75% {
        border-radius: 30% 70% 70% 30% / 70% 30% 30% 70%;
        transform: scale(1.05) rotate(270deg);
      }
    }
  </style>
</head>
<body>
<!-- Advanced Background Systems -->
<div class="bg-pattern">
  <div class="bg-shape"></div>
  <div class="bg-shape"></div>
  <div class="bg-shape"></div>
</div>

<!-- Neural Network Background -->
<canvas class="neural-network" id="neuralNetwork"></canvas>

<!-- Quantum Field Effects -->
<div class="quantum-field" id="quantumField">
  <div class="wave-particle"></div>
  <div class="wave-particle"></div>
  <div class="wave-particle"></div>
  <div class="wave-particle"></div>
  <div class="wave-particle"></div>
</div>

<!-- Holographic Projection -->
<div class="holographic-projection" id="holographicProjection">
  <div class="holo-layer holo-layer-1"></div>
  <div class="holo-layer holo-layer-2"></div>
  <div class="holo-layer holo-layer-3"></div>
  <div class="holo-layer holo-layer-4"></div>
</div>

<!-- Advanced Particle System -->
<canvas class="advanced-particles" id="advancedParticles"></canvas>

<!-- Interactive Particle Background -->
<div class="particles" id="particles"></div>

<!-- Cryptographic Animation -->
<div class="crypto-animation">
  <div class="crypto-bits"></div>
</div>

<!-- AI Processing Indicator -->
<div class="ai-indicator" id="aiIndicator" title="AI Adaptive System Active">
  <i class="fas fa-brain"></i>
</div>

<!-- Gesture Drawing Canvas -->
<svg class="gesture-canvas" id="gestureCanvas">
  <path class="gesture-path-drawn" id="gesturePath"></path>
</svg>

<!-- Advanced Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="loading-content">
    <div class="loading-spinner"></div>
    <div class="loading-text">Authenticating...</div>
    <div class="loading-subtext">AI-powered security analysis in progress</div>
  </div>
</div>

  <div class="card">
    <div class="logo-container">
      <div class="logo-ring"></div>
      <img src="/logo" class="logo" alt="User Logo">
      <div class="biometric-overlay" id="biometricOverlay">
        <div class="biometric-methods">
          <div class="biometric-method fingerprint" data-method="fingerprint">
            <i class="fas fa-fingerprint biometric-icon"></i>
            <span>Fingerprint</span>
          </div>
          <div class="biometric-method face" data-method="face">
            <i class="fas fa-face-smile biometric-icon"></i>
            <span>Face ID</span>
          </div>
          <div class="biometric-method voice" data-method="voice">
            <i class="fas fa-microphone biometric-icon"></i>
            <span>Voice</span>
          </div>
          <div class="biometric-method gesture" data-method="gesture">
            <i class="fas fa-hand biometric-icon"></i>
            <span>Gesture</span>
          </div>
        </div>
        <div class="biometric-pulse"></div>
        <div class="gesture-hint" id="gestureHint">
          <div class="gesture-path"></div>
          <span>Draw authentication pattern</span>
        </div>
      </div>
    </div>
    
    <div class="title">HenSpectral</div>
    <div class="subtitle"><pre>Gateway to System Endpoint API</pre></div>

    <form method="POST" action="/auth" id="loginForm" style="display: flex; flex-direction: column; width: 100%;">
      <div class="form-group">
        <div class="input-container">
          <i class="fas fa-user"></i>
          <input type="text" name="username" id="username" placeholder="Enter your username" required />
        </div>
      </div>
      <div class="form-group">
        <div class="input-container">
          <i class="fas fa-key"></i>
          <input type="password" name="key" id="password" placeholder="Enter your password (optional)" />
        </div>
      </div>
      <button type="submit" id="loginBtn">
        <span class="btn-text">
          <i class="fa-solid fa-right-to-bracket"></i> LOGIN
        </span>
        <div class="btn-loader" style="display: none;">
          <div class="spinner"></div>
        </div>
      </button>
    </form>

    <div style="margin-top: 20px;">
      <a class="buy-access" href="https://t.me/Hendra Roorr" target="_blank">
        <i class="fas fa-coins"></i> Get Key Access
      </a>

      <div class="footer" style="margin-top: 20px;">Â© 2025 - Hendra Roorr | Secure System Interface</div>
    </div>
  </div>

  <div id="toast" class="toast" style="display:none;"></div>
  
  <script>
    // Advanced System Variables
    let particles = [];
    let mouseX = 0, mouseY = 0;
    let animationId, neuralAnimationId, advancedParticleId;
    let userBehavior = { clicks: 0, timeSpent: 0, interactions: [] };
    let neuralNodes = [];
    let gesturePath = [];
    let isDrawing = false;

    // Neural Network Visualization
    class NeuralNetwork {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.nodes = [];
        this.connections = [];
        this.init();
      }

      init() {
        this.resize();
        this.createNodes();
        this.createConnections();
      }

      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }

      createNodes() {
        const nodeCount = 25;
        for (let i = 0; i < nodeCount; i++) {
          this.nodes.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: Math.random() * 3 + 1,
            connections: []
          });
        }
      }

      createConnections() {
        this.nodes.forEach((node, i) => {
          const connectionCount = Math.floor(Math.random() * 3) + 1;
          for (let j = 0; j < connectionCount; j++) {
            const targetIndex = Math.floor(Math.random() * this.nodes.length);
            if (targetIndex !== i) {
              node.connections.push(targetIndex);
            }
          }
        });
      }

      update() {
        this.nodes.forEach(node => {
          node.x += node.vx;
          node.y += node.vy;

          // Bounce off edges
          if (node.x <= 0 || node.x >= this.canvas.width) node.vx *= -1;
          if (node.y <= 0 || node.y >= this.canvas.height) node.vy *= -1;

          // Mouse interaction
          const dx = mouseX - node.x;
          const dy = mouseY - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 100) {
            const force = (100 - distance) / 100;
            node.vx += dx * force * 0.0001;
            node.vy += dy * force * 0.0001;
          }
        });
      }

      draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw connections
        this.ctx.strokeStyle = 'rgba(0,136,204,0.1)';
        this.ctx.lineWidth = 1;

        this.nodes.forEach((node, i) => {
          node.connections.forEach(targetIndex => {
            const target = this.nodes[targetIndex];
            this.ctx.beginPath();
            this.ctx.moveTo(node.x, node.y);
            this.ctx.lineTo(target.x, target.y);
            this.ctx.stroke();
          });
        });

        // Draw nodes
        this.nodes.forEach(node => {
          this.ctx.beginPath();
          this.ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
          this.ctx.fillStyle = `rgba(0,136,204,${0.3 + Math.random() * 0.4})`;
          this.ctx.fill();
        });
      }

      animate() {
        this.update();
        this.draw();
        neuralAnimationId = requestAnimationFrame(() => this.animate());
      }
    }

    // Advanced Particle System (WebGL-like)
    class AdvancedParticleSystem {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.particles = [];
        this.init();
      }

      init() {
        this.resize();
        this.createParticles();
      }

      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }

      createParticles() {
        const particleCount = 50;
        for (let i = 0; i < particleCount; i++) {
          this.particles.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            life: Math.random() * 100 + 50,
            maxLife: Math.random() * 100 + 50,
            size: Math.random() * 4 + 1,
            color: this.getRandomColor(),
            connections: []
          });
        }
      }

      getRandomColor() {
        const colors = [
          'rgba(0,136,204,0.6)',
          'rgba(52,152,219,0.6)',
          'rgba(77,166,217,0.6)',
          'rgba(125,206,250,0.6)'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      update() {
        this.particles.forEach((particle, i) => {
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.life--;

          // Mouse interaction
          const dx = mouseX - particle.x;
          const dy = mouseY - particle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 120) {
            const force = (120 - distance) / 120;
            particle.vx += dx * force * 0.0002;
            particle.vy += dy * force * 0.0002;
          }

          // Bounce off edges
          if (particle.x <= 0 || particle.x >= this.canvas.width) particle.vx *= -1;
          if (particle.y <= 0 || particle.y >= this.canvas.height) particle.vy *= -1;

          // Respawn dead particles
          if (particle.life <= 0) {
            particle.x = Math.random() * this.canvas.width;
            particle.y = Math.random() * this.canvas.height;
            particle.life = particle.maxLife;
            particle.vx = (Math.random() - 0.5) * 2;
            particle.vy = (Math.random() - 0.5) * 2;
          }
        });
      }

      draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw connections between nearby particles
        this.ctx.strokeStyle = 'rgba(0,136,204,0.1)';
        this.ctx.lineWidth = 0.5;

        for (let i = 0; i < this.particles.length; i++) {
          for (let j = i + 1; j < this.particles.length; j++) {
            const p1 = this.particles[i];
            const p2 = this.particles[j];
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 80) {
              this.ctx.beginPath();
              this.ctx.moveTo(p1.x, p1.y);
              this.ctx.lineTo(p2.x, p2.y);
              this.ctx.stroke();
            }
          }
        }

        // Draw particles
        this.particles.forEach(particle => {
          const alpha = particle.life / particle.maxLife;
          this.ctx.globalAlpha = alpha;

          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          this.ctx.fillStyle = particle.color.replace('0.6', alpha.toString());
          this.ctx.fill();

          // Glow effect
          this.ctx.shadowBlur = 10;
          this.ctx.shadowColor = particle.color;
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
        });

        this.ctx.globalAlpha = 1;
      }

      animate() {
        this.update();
        this.draw();
        advancedParticleId = requestAnimationFrame(() => this.animate());
      }
    }

    // AI-Powered Adaptive Animations
    class AdaptiveAnimationSystem {
      constructor() {
        this.intensity = 1;
        this.userPatterns = [];
        this.lastInteraction = Date.now();
      }

      trackInteraction(type, data) {
        this.userPatterns.push({ type, data, timestamp: Date.now() });
        this.lastInteraction = Date.now();

        // Analyze patterns and adjust intensity
        this.analyzePatterns();
      }

      analyzePatterns() {
        const recentPatterns = this.userPatterns.filter(p =>
          Date.now() - p.timestamp < 30000 // Last 30 seconds
        );

        if (recentPatterns.length > 5) {
          this.intensity = Math.min(2, this.intensity + 0.1);
        } else if (recentPatterns.length < 2) {
          this.intensity = Math.max(0.5, this.intensity - 0.05);
        }

        this.applyIntensity();
      }

      applyIntensity() {
        const card = document.querySelector('.card');
        const particles = document.querySelectorAll('.particle');

        // Adjust card animation intensity
        card.style.animationDuration = `${6 / this.intensity}s`;

        // Adjust particle animation speed
        particles.forEach(particle => {
          const currentDuration = parseFloat(particle.style.animationDuration);
          particle.style.animationDuration = `${currentDuration / this.intensity}s`;
        });
      }
    }

    // Gesture Recognition System
    class GestureSystem {
      constructor() {
        this.path = [];
        this.isRecording = false;
        this.patterns = [];
      }

      startRecording() {
        this.path = [];
        this.isRecording = true;
      }

      recordPoint(x, y) {
        if (this.isRecording) {
          this.path.push({ x, y, timestamp: Date.now() });
        }
      }

      stopRecording() {
        this.isRecording = false;
        return this.analyzePattern();
      }

      analyzePattern() {
        if (this.path.length < 10) return false;

        // Simple pattern recognition (could be much more sophisticated)
        const start = this.path[0];
        const end = this.path[this.path.length - 1];
        const dx = end.x - start.x;
        const dy = end.y - start.y;

        // Detect circular pattern
        const isCircular = this.detectCircularPattern();
        // Detect L-shape pattern
        const isLShape = Math.abs(dx) > 50 && Math.abs(dy) > 50;

        return { isCircular, isLShape, confidence: 0.8 };
      }

      detectCircularPattern() {
        if (this.path.length < 20) return false;

        const center = this.path[Math.floor(this.path.length / 2)];
        let totalDistance = 0;

        this.path.forEach(point => {
          const dx = point.x - center.x;
          const dy = point.y - center.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          totalDistance += distance;
        });

        const avgDistance = totalDistance / this.path.length;
        const variance = this.path.reduce((acc, point) => {
          const dx = point.x - center.x;
          const dy = point.y - center.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return acc + Math.pow(distance - avgDistance, 2);
        }, 0) / this.path.length;

        return variance < 1000; // Low variance indicates circular pattern
      }
    }

    // Basic Form Validation (username only)
    class BasicValidationSystem {
      constructor() {
        // No suggestions or complex validation
      }

      validateUsername(username) {
        const issues = [];

        if (username.length < 3) {
          issues.push('Username too short');
        }
        if (username.length > 20) {
          issues.push('Username too long');
        }
        if (!/^[a-zA-Z0-9_]+$/.test(username)) {
          issues.push('Only letters, numbers, and underscores allowed');
        }

        return {
          isValid: issues.length === 0,
          issues
        };
      }
    }

    // Initialize all advanced systems
    let neuralNetwork, advancedParticles, adaptiveSystem, gestureSystem, basicValidation;

    function initializeAdvancedSystems() {
      // Neural Network
      const neuralCanvas = document.getElementById('neuralNetwork');
      neuralNetwork = new NeuralNetwork(neuralCanvas);

      // Advanced Particles
      const particleCanvas = document.getElementById('advancedParticles');
      advancedParticles = new AdvancedParticleSystem(particleCanvas);

      // AI Adaptive System
      adaptiveSystem = new AdaptiveAnimationSystem();

      // Gesture System
      gestureSystem = new GestureSystem();

      // Basic Validation
      basicValidation = new BasicValidationSystem();

      // Start animations
      neuralNetwork.animate();
      advancedParticles.animate();
    }

    // Mouse tracking (throttled for performance)
    let mouseThrottleTimeout;
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;

      // Throttle adaptive system tracking to reduce performance impact
      clearTimeout(mouseThrottleTimeout);
      mouseThrottleTimeout = setTimeout(() => {
        adaptiveSystem.trackInteraction('mousemove', { x: mouseX, y: mouseY });
      }, 100); // Only track every 100ms instead of every mousemove
    });


    // Basic form validation (throttled for performance)
    function initBasicValidation() {
      const usernameInput = document.getElementById('username');
      let validationTimeout;

      usernameInput.addEventListener('input', function() {
        clearTimeout(validationTimeout);
        validationTimeout = setTimeout(() => {
          const result = basicValidation.validateUsername(this.value);
          updateBasicValidationUI(this, result);
        }, 300); // Throttle validation to 300ms
      });

      // Only validate on blur for immediate feedback
      usernameInput.addEventListener('blur', function() {
        const result = basicValidation.validateUsername(this.value);
        updateBasicValidationUI(this, result);
      });
    }

    function updateBasicValidationUI(input, result) {
      const formGroup = input.parentElement;
      formGroup.classList.remove('input-error', 'input-success');

      if (input.value.length > 0) {
        formGroup.classList.add(result.isValid ? 'input-success' : 'input-error');
      }
    }

    // Enhanced form submission
    function initAdvancedFormSubmission() {
      const form = document.getElementById('loginForm');
      const loginBtn = document.getElementById('loginBtn');

      form.addEventListener('submit', function(e) {
        const username = document.getElementById('username').value.trim();
        const password = document.getElementById('password').value.trim();

        if (!username) {
          e.preventDefault();
          showToast('Please enter a username', 'error');
          return;
        }

        // Basic validation (username required, password optional)
        const usernameResult = basicValidation.validateUsername(username);

        if (!usernameResult.isValid) {
          e.preventDefault();
          showToast('Please enter a valid username', 'error');
          return;
        }

        // Password is optional, just validate if provided
        const passwordResult = password ? smartValidation.validatePassword(password) : { isValid: true, strength: 0 };

        // Show success message for optional password
        if (!password) {
          showToast('Logging in with username only...', 'info');
        }

        // Show loading state with advanced effects
        loginBtn.classList.add('loading');
        loginBtn.disabled = true;

        // Trigger encryption animation
        triggerEncryptionAnimation();

        adaptiveSystem.trackInteraction('form_submit', {
          usernameValid: usernameResult.isValid,
          passwordStrength: passwordResult.strength
        });

        // Simulate advanced processing
        setTimeout(() => {
          loginBtn.classList.remove('loading');
          loginBtn.disabled = false;
        }, 3000);
      });
    }

    // Encryption animation
    function triggerEncryptionAnimation() {
      const cryptoElement = document.querySelector('.crypto-animation');
      cryptoElement.style.animation = 'cryptoFlow 1s ease-in-out infinite';

      setTimeout(() => {
        cryptoElement.style.animation = 'cryptoFlow 4s linear infinite';
      }, 2000);
    }

    // Advanced biometric system
    function initAdvancedBiometric() {
      const biometricOverlay = document.getElementById('biometricOverlay');
      const biometricMethods = document.querySelectorAll('.biometric-method');
      const gestureHint = document.getElementById('gestureHint');
      const logoContainer = document.querySelector('.logo-container');

      logoContainer.addEventListener('click', function() {
        biometricOverlay.classList.add('active');
        adaptiveSystem.trackInteraction('biometric_open', {});
      });

      biometricMethods.forEach(method => {
        method.addEventListener('click', function() {
          const methodType = this.dataset.method;
          biometricMethods.forEach(m => m.classList.remove('active'));
          this.classList.add('active');

          switch(methodType) {
            case 'fingerprint':
              simulateFingerprint();
              break;
            case 'face':
              simulateFaceID();
              break;
            case 'voice':
              simulateVoice();
              break;
            case 'gesture':
              showGestureHint();
              break;
          }

          adaptiveSystem.trackInteraction('biometric_method', { method: methodType });
        });
      });

      // Gesture drawing
      document.addEventListener('mousedown', (e) => {
        if (gestureHint.classList.contains('active')) {
          gestureSystem.startRecording();
          isDrawing = true;
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (isDrawing) {
          gestureSystem.recordPoint(e.clientX, e.clientY);
        }
      });

      document.addEventListener('mouseup', () => {
        if (isDrawing) {
          const result = gestureSystem.stopRecording();
          isDrawing = false;

          if (result.isCircular || result.isLShape) {
            showToast('Gesture recognized! Authentication successful.', 'success');
            setTimeout(() => {
              biometricOverlay.classList.remove('active');
            }, 2000);
          } else {
            showToast('Gesture not recognized. Try again.', 'error');
          }
        }
      });
    }

    function simulateFingerprint() {
      showToast('Place your finger on the sensor...', 'info');
      setTimeout(() => {
        showToast('Fingerprint authenticated!', 'success');
        setTimeout(() => {
          document.getElementById('biometricOverlay').classList.remove('active');
        }, 1500);
      }, 2000);
    }

    function simulateFaceID() {
      showToast('Look at the camera...', 'info');
      setTimeout(() => {
        showToast('Face ID authenticated!', 'success');
        setTimeout(() => {
          document.getElementById('biometricOverlay').classList.remove('active');
        }, 1500);
      }, 2500);
    }

    function simulateVoice() {
      showToast('Say "Access granted"...', 'info');
      setTimeout(() => {
        showToast('Voice authenticated!', 'success');
        setTimeout(() => {
          document.getElementById('biometricOverlay').classList.remove('active');
        }, 1500);
      }, 3000);
    }

    function showGestureHint() {
      const gestureHint = document.getElementById('gestureHint');
      gestureHint.classList.add('active');
      showToast('Draw an authentication pattern', 'info');
    }

    // Enhanced toast system
    function showToast(message, type = 'info') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${type}`;
      toast.style.display = 'block';

      // Add vibration effect for mobile
      if ('vibrate' in navigator) {
        navigator.vibrate(type === 'error' ? [100, 50, 100] : [50]);
      }

      setTimeout(() => {
        toast.style.display = 'none';
      }, 4000);
    }

    // Matrix transformation effects
    function initMatrixEffects() {
      const card = document.querySelector('.card');

      card.addEventListener('mouseenter', () => {
        card.style.transform = 'perspective(1000px) rotateX(5deg) rotateY(5deg) scale(1.02)';
      });

      card.addEventListener('mouseleave', () => {
        card.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) scale(1)';
      });
    }

    // Create interactive particle background
    function createParticles() {
      const particlesContainer = document.getElementById('particles');
      const particleCount = 25;

      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.classList.add('particle');

        const size = Math.random() * 6 + 2;
        const posX = Math.random() * 100;
        const posY = Math.random() * 100;
        const delay = Math.random() * 5;
        const duration = Math.random() * 4 + 6;

        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.left = `${posX}%`;
        particle.style.top = `${posY}%`;
        particle.style.animationDelay = `${delay}s`;
        particle.style.animationDuration = `${duration}s`;

        const colors = ['#0088cc', '#3498db', '#4da6d9', '#5dade2'];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        particle.style.background = randomColor;

        particle.dataset.originalX = posX;
        particle.dataset.originalY = posY;
        particle.dataset.speedX = (Math.random() - 0.5) * 0.5;
        particle.dataset.speedY = (Math.random() - 0.5) * 0.5;

        particles.push(particle);
        particlesContainer.appendChild(particle);
      }
    }

    // Interactive particle animation
    function animateParticles() {
      particles.forEach(particle => {
        const rect = particle.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const dx = mouseX - centerX;
        const dy = mouseY - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 150) {
          const force = (150 - distance) / 150;
          const currentX = parseFloat(particle.style.left);
          const currentY = parseFloat(particle.style.top);

          particle.style.left = `${currentX + dx * force * 0.001}%`;
          particle.style.top = `${currentY + dy * force * 0.001}%`;
          particle.classList.add('interactive');
        } else {
          particle.classList.remove('interactive');
        }
      });

      animationId = requestAnimationFrame(animateParticles);
    }

    // Ripple effect
    function createRipple(event, element) {
      const ripple = document.createElement('div');
      const rect = element.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height);
      const x = event.clientX - rect.left - size / 2;
      const y = event.clientY - rect.top - size / 2;

      ripple.style.width = ripple.style.height = size + 'px';
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';
      ripple.classList.add('ripple');

      element.appendChild(ripple);

      setTimeout(() => {
        ripple.remove();
      }, 600);
    }

    // Toast message handling from URL params
    const params = new URLSearchParams(window.location.search);
    const msg = params.get("msg");

    if (msg) {
      showToast(msg, msg.includes('success') ? 'success' : 'error');
    }

    // Initialize all advanced systems
    document.addEventListener('DOMContentLoaded', function() {
      initializeAdvancedSystems();
      createParticles();
      animateParticles();
      initBasicValidation();
      initAdvancedFormSubmission();
      initAdvancedBiometric();
      initMatrixEffects();
      initAIIndicator();
      initGestureCanvas();

      // Simplified focus effects (no expensive animations)
      const inputs = document.querySelectorAll('input');
      inputs.forEach(input => {
        input.addEventListener('focus', function() {
          this.parentElement.querySelector('i').style.color = 'var(--primary)';
        });

        input.addEventListener('blur', function() {
          this.parentElement.querySelector('i').style.color = 'var(--secondary)';
        });
      });

      // Removed expensive card tilt effect for better performance
      // Card now uses static transform from CSS

      // Track user behavior
      setInterval(() => {
        userBehavior.timeSpent += 1;
        adaptiveSystem.trackInteraction('time_spent', { seconds: userBehavior.timeSpent });
      }, 1000);
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (animationId) cancelAnimationFrame(animationId);
      if (neuralAnimationId) cancelAnimationFrame(neuralAnimationId);
      if (advancedParticleId) cancelAnimationFrame(advancedParticleId);
    });

    // AI Indicator
    function initAIIndicator() {
      const aiIndicator = document.getElementById('aiIndicator');

      aiIndicator.addEventListener('click', () => {
        showToast(`AI System Active - Intensity: ${(adaptiveSystem.intensity * 100).toFixed(0)}%`, 'info');
        adaptiveSystem.trackInteraction('ai_indicator_click', {});
      });

      // Pulse based on activity
      setInterval(() => {
        const pulseIntensity = 1 + (adaptiveSystem.intensity - 1) * 0.5;
        aiIndicator.style.transform = `scale(${pulseIntensity})`;
      }, 2000);
    }

    // Gesture Canvas Visualization
    function initGestureCanvas() {
      const gestureCanvas = document.getElementById('gestureCanvas');
      const gesturePath = document.getElementById('gesturePath');

      document.addEventListener('mousedown', (e) => {
        if (document.getElementById('gestureHint').classList.contains('active')) {
          gestureSystem.startRecording();
          isDrawing = true;
          gesturePath.setAttribute('d', `M ${e.clientX} ${e.clientY}`);
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (isDrawing) {
          gestureSystem.recordPoint(e.clientX, e.clientY);
          const currentPath = gesturePath.getAttribute('d') || '';
          gesturePath.setAttribute('d', `${currentPath} L ${e.clientX} ${e.clientY}`);
        }
      });

      document.addEventListener('mouseup', () => {
        if (isDrawing) {
          const result = gestureSystem.stopRecording();
          isDrawing = false;

          setTimeout(() => {
            gesturePath.setAttribute('d', '');
          }, 1000);

          if (result.isCircular || result.isLShape) {
            showToast('Gesture recognized! Authentication successful.', 'success');
            setTimeout(() => {
              document.getElementById('biometricOverlay').classList.remove('active');
              document.getElementById('gestureHint').classList.remove('active');
            }, 2000);
          } else {
            showToast('Gesture not recognized. Try again.', 'error');
          }
        }
      });
    }

    // Enhanced form submission with loading overlay
    function initAdvancedFormSubmission() {
      const form = document.getElementById('loginForm');
      const loginBtn = document.getElementById('loginBtn');
      const loadingOverlay = document.getElementById('loadingOverlay');

      form.addEventListener('submit', function(e) {
        const username = document.getElementById('username').value.trim();
        const password = document.getElementById('password').value.trim();

        if (!username || !password) {
          e.preventDefault();
          showToast('Please fill in all fields', 'error');
          return;
        }

        // Advanced validation
        const usernameResult = smartValidation.validateUsername(username);
        const passwordResult = smartValidation.validatePassword(password);

        if (!usernameResult.isValid || !passwordResult.isValid) {
          e.preventDefault();
          showToast('Please fix validation errors', 'error');
          return;
        }

        // Show advanced loading overlay
        loadingOverlay.classList.add('active');
        loginBtn.classList.add('loading');
        loginBtn.disabled = true;

        // Trigger encryption animation
        triggerEncryptionAnimation();

        adaptiveSystem.trackInteraction('form_submit', {
          usernameValid: usernameResult.isValid,
          passwordStrength: passwordResult.strength
        });

        // Simulate advanced processing with multiple stages
        const stages = ['Analyzing credentials...', 'AI security check...', 'Biometric verification...', 'Access granted!'];
        let stageIndex = 0;

        const stageInterval = setInterval(() => {
          if (stageIndex < stages.length - 1) {
            document.querySelector('.loading-subtext').textContent = stages[stageIndex];
            stageIndex++;
          } else {
            clearInterval(stageInterval);
            setTimeout(() => {
              loadingOverlay.classList.remove('active');
              loginBtn.classList.remove('loading');
              loginBtn.disabled = false;
              showToast('Login successful!', 'success');
            }, 1000);
          }
        }, 800);
      });
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      if (neuralNetwork) neuralNetwork.resize();
      if (advancedParticles) advancedParticles.resize();
    });
  </script>
</body>
</html>